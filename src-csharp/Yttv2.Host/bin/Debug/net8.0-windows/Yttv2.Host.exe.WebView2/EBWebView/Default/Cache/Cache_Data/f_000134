{"version":3,"sources":["../../fft-js/src/complex.js","../../fft-js/src/fftutil.js","../../bit-twiddle/twiddle.js","../../fft-js/src/fft.js","../../fft-js/src/ifft.js","../../fft-js/src/dft.js","../../fft-js/src/idft.js","../../fft-js/index.js"],"sourcesContent":["//-------------------------------------------------\n// Add two complex numbers\n//-------------------------------------------------\nvar complexAdd = function (a, b)\n{\n    return [a[0] + b[0], a[1] + b[1]];\n};\n\n//-------------------------------------------------\n// Subtract two complex numbers\n//-------------------------------------------------\nvar complexSubtract = function (a, b)\n{\n    return [a[0] - b[0], a[1] - b[1]];\n};\n\n//-------------------------------------------------\n// Multiply two complex numbers\n//\n// (a + bi) * (c + di) = (ac - bd) + (ad + bc)i\n//-------------------------------------------------\nvar complexMultiply = function (a, b) \n{\n    return [(a[0] * b[0] - a[1] * b[1]), \n            (a[0] * b[1] + a[1] * b[0])];\n};\n\n//-------------------------------------------------\n// Calculate |a + bi|\n//\n// sqrt(a*a + b*b)\n//-------------------------------------------------\nvar complexMagnitude = function (c) \n{\n    return Math.sqrt(c[0]*c[0] + c[1]*c[1]); \n};\n\n//-------------------------------------------------\n// Exports\n//-------------------------------------------------\nmodule.exports = {\n    add: complexAdd,\n    subtract: complexSubtract,\n    multiply: complexMultiply,\n    magnitude: complexMagnitude\n};\n","/*===========================================================================*\\\n * Fast Fourier Transform Frequency/Magnitude passes\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\nvar complex = require('./complex');\n\n\n//-------------------------------------------------\n// By Eulers Formula:\n//\n// e^(i*x) = cos(x) + i*sin(x)\n//\n// and in DFT:\n//\n// x = -2*PI*(k/N)\n//-------------------------------------------------\nvar mapExponent = {},\n    exponent = function (k, N) {\n      var x = -2 * Math.PI * (k / N);\n\n      mapExponent[N] = mapExponent[N] || {};\n      mapExponent[N][k] = mapExponent[N][k] || [Math.cos(x), Math.sin(x)];// [Real, Imaginary]\n\n      return mapExponent[N][k];\n};\n\n//-------------------------------------------------\n// Calculate FFT Magnitude for complex numbers.\n//-------------------------------------------------\nvar fftMag = function (fftBins) {\n    var ret = fftBins.map(complex.magnitude);\n    return ret.slice(0, ret.length / 2);\n};\n\n//-------------------------------------------------\n// Calculate Frequency Bins\n// \n// Returns an array of the frequencies (in hertz) of\n// each FFT bin provided, assuming the sampleRate is\n// samples taken per second.\n//-------------------------------------------------\nvar fftFreq = function (fftBins, sampleRate) {\n    var stepFreq = sampleRate / (fftBins.length);\n    var ret = fftBins.slice(0, fftBins.length / 2);\n\n    return ret.map(function (__, ix) {\n        return ix * stepFreq;\n    });\n};\n\n//-------------------------------------------------\n// Exports\n//-------------------------------------------------\nmodule.exports = {\n    fftMag: fftMag,\n    fftFreq: fftFreq,\n    exponent: exponent\n};\n","/**\n * Bit twiddling hacks for JavaScript.\n *\n * Author: Mikola Lysenko\n *\n * Ported from Stanford bit twiddling hack library:\n *    http://graphics.stanford.edu/~seander/bithacks.html\n */\n\n\"use strict\"; \"use restrict\";\n\n//Number of bits in an integer\nvar INT_BITS = 32;\n\n//Constants\nexports.INT_BITS  = INT_BITS;\nexports.INT_MAX   =  0x7fffffff;\nexports.INT_MIN   = -1<<(INT_BITS-1);\n\n//Returns -1, 0, +1 depending on sign of x\nexports.sign = function(v) {\n  return (v > 0) - (v < 0);\n}\n\n//Computes absolute value of integer\nexports.abs = function(v) {\n  var mask = v >> (INT_BITS-1);\n  return (v ^ mask) - mask;\n}\n\n//Computes minimum of integers x and y\nexports.min = function(x, y) {\n  return y ^ ((x ^ y) & -(x < y));\n}\n\n//Computes maximum of integers x and y\nexports.max = function(x, y) {\n  return x ^ ((x ^ y) & -(x < y));\n}\n\n//Checks if a number is a power of two\nexports.isPow2 = function(v) {\n  return !(v & (v-1)) && (!!v);\n}\n\n//Computes log base 2 of v\nexports.log2 = function(v) {\n  var r, shift;\n  r =     (v > 0xFFFF) << 4; v >>>= r;\n  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;\n  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;\n  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;\n  return r | (v >> 1);\n}\n\n//Computes log base 10 of v\nexports.log10 = function(v) {\n  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :\n          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :\n          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;\n}\n\n//Counts number of bits\nexports.popCount = function(v) {\n  v = v - ((v >>> 1) & 0x55555555);\n  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);\n  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;\n}\n\n//Counts number of trailing zeros\nfunction countTrailingZeros(v) {\n  var c = 32;\n  v &= -v;\n  if (v) c--;\n  if (v & 0x0000FFFF) c -= 16;\n  if (v & 0x00FF00FF) c -= 8;\n  if (v & 0x0F0F0F0F) c -= 4;\n  if (v & 0x33333333) c -= 2;\n  if (v & 0x55555555) c -= 1;\n  return c;\n}\nexports.countTrailingZeros = countTrailingZeros;\n\n//Rounds to next power of 2\nexports.nextPow2 = function(v) {\n  v += v === 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\n\n//Rounds down to previous power of 2\nexports.prevPow2 = function(v) {\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v - (v>>>1);\n}\n\n//Computes parity of word\nexports.parity = function(v) {\n  v ^= v >>> 16;\n  v ^= v >>> 8;\n  v ^= v >>> 4;\n  v &= 0xf;\n  return (0x6996 >>> v) & 1;\n}\n\nvar REVERSE_TABLE = new Array(256);\n\n(function(tab) {\n  for(var i=0; i<256; ++i) {\n    var v = i, r = i, s = 7;\n    for (v >>>= 1; v; v >>>= 1) {\n      r <<= 1;\n      r |= v & 1;\n      --s;\n    }\n    tab[i] = (r << s) & 0xff;\n  }\n})(REVERSE_TABLE);\n\n//Reverse bits in a 32 bit word\nexports.reverse = function(v) {\n  return  (REVERSE_TABLE[ v         & 0xff] << 24) |\n          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |\n          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |\n           REVERSE_TABLE[(v >>> 24) & 0xff];\n}\n\n//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes\nexports.interleave2 = function(x, y) {\n  x &= 0xFFFF;\n  x = (x | (x << 8)) & 0x00FF00FF;\n  x = (x | (x << 4)) & 0x0F0F0F0F;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n\n  y &= 0xFFFF;\n  y = (y | (y << 8)) & 0x00FF00FF;\n  y = (y | (y << 4)) & 0x0F0F0F0F;\n  y = (y | (y << 2)) & 0x33333333;\n  y = (y | (y << 1)) & 0x55555555;\n\n  return x | (y << 1);\n}\n\n//Extracts the nth interleaved component\nexports.deinterleave2 = function(v, n) {\n  v = (v >>> n) & 0x55555555;\n  v = (v | (v >>> 1))  & 0x33333333;\n  v = (v | (v >>> 2))  & 0x0F0F0F0F;\n  v = (v | (v >>> 4))  & 0x00FF00FF;\n  v = (v | (v >>> 16)) & 0x000FFFF;\n  return (v << 16) >> 16;\n}\n\n\n//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes\nexports.interleave3 = function(x, y, z) {\n  x &= 0x3FF;\n  x  = (x | (x<<16)) & 4278190335;\n  x  = (x | (x<<8))  & 251719695;\n  x  = (x | (x<<4))  & 3272356035;\n  x  = (x | (x<<2))  & 1227133513;\n\n  y &= 0x3FF;\n  y  = (y | (y<<16)) & 4278190335;\n  y  = (y | (y<<8))  & 251719695;\n  y  = (y | (y<<4))  & 3272356035;\n  y  = (y | (y<<2))  & 1227133513;\n  x |= (y << 1);\n  \n  z &= 0x3FF;\n  z  = (z | (z<<16)) & 4278190335;\n  z  = (z | (z<<8))  & 251719695;\n  z  = (z | (z<<4))  & 3272356035;\n  z  = (z | (z<<2))  & 1227133513;\n  \n  return x | (z << 2);\n}\n\n//Extracts nth interleaved component of a 3-tuple\nexports.deinterleave3 = function(v, n) {\n  v = (v >>> n)       & 1227133513;\n  v = (v | (v>>>2))   & 3272356035;\n  v = (v | (v>>>4))   & 251719695;\n  v = (v | (v>>>8))   & 4278190335;\n  v = (v | (v>>>16))  & 0x3FF;\n  return (v<<22)>>22;\n}\n\n//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)\nexports.nextCombination = function(v) {\n  var t = v | (v - 1);\n  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));\n}\n\n","/*===========================================================================*\\\n * Fast Fourier Transform (Cooley-Tukey Method)\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//------------------------------------------------\n// Note: Some of this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n// To get high performace would require transforming\n// the recursive calls into a loop and then loop\n// unrolling. All of this is best accomplished\n// in C or assembly.\n//-------------------------------------------------\n\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\nvar complex = require('./complex'),\n    fftUtil = require('./fftutil'),\n    twiddle = require('bit-twiddle');\n\nmodule.exports = {\n  //-------------------------------------------------\n  // Calculate FFT for vector where vector.length\n  // is assumed to be a power of 2.\n  //-------------------------------------------------\n  fft: function fft(vector) {\n    var X = [],\n        N = vector.length;\n\n    // Base case is X = x + 0i since our input is assumed to be real only.\n    if (N == 1) {\n      if (Array.isArray(vector[0])) //If input vector contains complex numbers\n        return [[vector[0][0], vector[0][1]]];      \n      else\n        return [[vector[0], 0]];\n    }\n\n    // Recurse: all even samples\n    var X_evens = fft(vector.filter(even)),\n\n        // Recurse: all odd samples\n        X_odds  = fft(vector.filter(odd));\n\n    // Now, perform N/2 operations!\n    for (var k = 0; k < N / 2; k++) {\n      // t is a complex number!\n      var t = X_evens[k],\n          e = complex.multiply(fftUtil.exponent(k, N), X_odds[k]);\n\n      X[k] = complex.add(t, e);\n      X[k + (N / 2)] = complex.subtract(t, e);\n    }\n\n    function even(__, ix) {\n      return ix % 2 == 0;\n    }\n\n    function odd(__, ix) {\n      return ix % 2 == 1;\n    }\n\n    return X;\n  },\n  //-------------------------------------------------\n  // Calculate FFT for vector where vector.length\n  // is assumed to be a power of 2.  This is the in-\n  // place implementation, to avoid the memory\n  // footprint used by recursion.\n  //-------------------------------------------------\n  fftInPlace: function(vector) {\n    var N = vector.length;\n\n    var trailingZeros = twiddle.countTrailingZeros(N); //Once reversed, this will be leading zeros\n\n    // Reverse bits\n    for (var k = 0; k < N; k++) {\n      var p = twiddle.reverse(k) >>> (twiddle.INT_BITS - trailingZeros);\n      if (p > k) {\n        var complexTemp = [vector[k], 0];\n        vector[k] = vector[p];\n        vector[p] = complexTemp;\n      } else {\n        vector[p] = [vector[p], 0];\n      }\n    }\n\n    //Do the DIT now in-place\n    for (var len = 2; len <= N; len += len) {\n      for (var i = 0; i < len / 2; i++) {\n        var w = fftUtil.exponent(i, len);\n        for (var j = 0; j < N / len; j++) {\n          var t = complex.multiply(w, vector[j * len + i + len / 2]);\n          vector[j * len + i + len / 2] = complex.subtract(vector[j * len + i], t);\n          vector[j * len + i] = complex.add(vector[j * len + i], t);\n        }\n      }\n    }\n  }\n};\n","/*===========================================================================*\\\n * Inverse Fast Fourier Transform (Cooley-Tukey Method)\n *\n * (c) Maximilian Bügler. 2016\n *\n * Based on and using the code by\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//------------------------------------------------\n// Note: Some of this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n// To get high performace would require transforming\n// the recursive calls into a loop and then loop\n// unrolling. All of this is best accomplished\n// in C or assembly.\n//-------------------------------------------------\n\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\n\nvar fft = require('./fft').fft;\n\n\nmodule.exports = {\n    ifft: function ifft(signal){\n        //Interchange real and imaginary parts\n        var csignal=[];\n        for(var i=0; i<signal.length; i++){\n            csignal[i]=[signal[i][1], signal[i][0]];\n        }\n    \n        //Apply fft\n        var ps=fft(csignal);\n        \n        //Interchange real and imaginary parts and normalize\n        var res=[];\n        for(var j=0; j<ps.length; j++){\n            res[j]=[ps[j][1]/ps.length, ps[j][0]/ps.length];\n        }\n        return res;\n    }\n};\n","/*===========================================================================*\\\n * Discrete Fourier Transform (O(n^2) brute-force method)\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//------------------------------------------------\n// Note: this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n//------------------------------------------------\nvar complex = require('./complex');\nvar fftUtil = require('./fftutil');\n\n//-------------------------------------------------\n// Calculate brute-force O(n^2) DFT for vector.\n//-------------------------------------------------\nvar dft = function(vector) {\n  var X = [],\n      N = vector.length;\n\n  for (var k = 0; k < N; k++) {\n    X[k] = [0, 0]; //Initialize to a 0-valued complex number.\n\n    for (var i = 0; i < N; i++) {\n      var exp = fftUtil.exponent(k * i, N);\n      var term;\n      if (Array.isArray(vector[i]))\n        term = complex.multiply(vector[i], exp)//If input vector contains complex numbers\n      else\n        term = complex.multiply([vector[i], 0], exp);//Complex mult of the signal with the exponential term.  \n      X[k] = complex.add(X[k], term); //Complex summation of X[k] and exponential\n    }\n  }\n\n  return X;\n};\n\nmodule.exports = dft;","/*===========================================================================*\\\n * Inverse Discrete Fourier Transform (O(n^2) brute-force method)\n *\n * (c) Maximilian Bügler. 2016\n *\n * Based on and using the code by\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//------------------------------------------------\n// Note: Some of this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n//-------------------------------------------------\n\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\nvar dft = require('./dft');\n\nfunction idft(signal) {\n    //Interchange real and imaginary parts\n    var csignal = [];\n    for (var i = 0; i < signal.length; i++) {\n        csignal[i] = [signal[i][1], signal[i][0]];\n    }\n\n    //Apply dft\n    var ps = dft(csignal);\n\n    //Interchange real and imaginary parts and normalize\n    var res = [];\n    for (var j = 0; j < ps.length; j++) {\n        res[j] = [ps[j][1] / ps.length, ps[j][0] / ps.length];\n    }\n    return res;\n}\n\nmodule.exports = idft;","/*===========================================================================*\\\n * Fast Fourier Transform (Cooley-Tukey Method)\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\nmodule.exports = {\n    fft: require('./src/fft').fft,\n    ifft: require('./src/ifft').ifft,\n    fftInPlace: require('./src/fft').fftInPlace,\n    util: require('./src/fftutil'),\n    dft: require('./src/dft'),\n    idft: require('./src/idft')\n};\n"],"mappings":"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","names":[],"x_google_ignoreList":[0,1,2,3,4,5,6,7]}